{
    "Slug": "an-end-to-end-prototype-of-aes-encryption-with-acs-authentication-and-acs-token-authorization",
    "Title": "An End-to-End Prototype of AES Encryption with ACS Authentication and ACS Token Authorization",
    "Summary": "This is a “sequel” to the author’s previous post An End-to-End Prototype of PlayReady Protection with ACS Authentication and ACS Token Authorization.",
    "Content": "<h1>Introduction</h1>\nThis is a “sequel” to the author’s previous post <a href=\"https://azure.microsoft.com/blog/2014/11/17/an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization/\" target=\"_blank\">An End-to-End Prototype of PlayReady Protection with ACS Authentication and ACS Token Authorization</a>.\n\nIn certain cases, full DRM protection may not be mandated or make economic sense. Instead, AES encryption can be an alternative. However, keep in mind that AES encryption is very different from and is not DRM. The differences between DRM and AES encryption can be summarized by the following table.\n<table border=\"0\" width=\"599\" cellspacing=\"0\" cellpadding=\"1\">\n<tbody>\n<tr>\n<td valign=\"top\" width=\"215\"><strong>Compare</strong></td>\n<td valign=\"top\" width=\"188\"><strong>DRM such as PlayReady</strong></td>\n<td valign=\"top\" width=\"194\"><strong>Encryption such as AES-128</strong></td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Protect content vs. protect file</td>\n<td valign=\"top\" width=\"188\">Content</td>\n<td valign=\"top\" width=\"194\">Content</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Is an authorized user trusted?</td>\n<td valign=\"top\" width=\"188\">No, What an Authorized user can do with the protected content is restricted by Restrictions and Rights contained in a DRM license.</td>\n<td valign=\"top\" width=\"194\">Yes, Authorized users can do anything with the content: copy, store, share, and/or export to any display devices</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Nature of content to be protected</td>\n<td valign=\"top\" width=\"188\">Applicable to content of shared interests, such as videos</td>\n<td valign=\"top\" width=\"194\">Applicable to personal content, users are trusted not to share.</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Is content protected after being decrypted on client devices?</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">No</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Can content access be restricted by date/time?</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">No</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Application whitelisting</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">No</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Domain binding and management</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">No</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Encryption key rotation</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">No</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Blackout</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">No</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">Output protection</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">No</td>\n</tr>\n<tr>\n<td valign=\"top\" width=\"215\">License chaining</td>\n<td valign=\"top\" width=\"188\">Yes</td>\n<td valign=\"top\" width=\"194\">No</td>\n</tr>\n</tbody>\n</table>\n<a href=\"https://azure.microsoft.com/blog/2014/09/10/announcing-public-availability-of-azure-media-services-content-protection-services/\">Azure Media Services Content Protection</a> also makes “1-Click” AES encryption a reality thanks to the dynamic AES encryption feature.\n\nIn this blog, we will present an end-to-end prototype of AES encryption of smooth streaming asset with token authorization. The authorization token is issued by the same ACS 2.0 namespace as used in the end-to-end prototype for PlayReady protection.\n\n&nbsp;\n<h1>The End-to-End Prototype</h1>\n<h2>Design and Functionality</h2>\nThe goal of this effort is to provide an end-to-end prototype covering the following\n<ul>\n <li>AES-128 dynamic encryption with Token Restriction for an asset in AMS;</li>\n <li>Azure Media Services key delivery service for delivering decryption key;</li>\n <li><a href=\"https://msdn.microsoft.com/en-us/library/azure/hh147631.aspx\">Azure ACS</a> (Microsoft Azure Active Directory Access Control) as an STS to issue SWT authorization tokens;</li>\n <li>An OSMF player\n<ol>\n <li>gets authenticated by ACS Service Identity,</li>\n <li>gets authorization token from ACS,</li>\n <li>acquires decryption key from AMS key delivery service with ACS token and</li>\n <li>decryption and video playback.</li>\n</ol>\n</li>\n</ul>\nThe design of this end-to-end prototype is illustrated by the following diagram.\n\n<a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/19/Blog_Secure_Delivery_AES.jpg\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"Blog_Secure_Delivery_AES\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/Blog_Secure_Delivery_AES_thumb.jpg\" alt=\"Blog_Secure_Delivery_AES\" width=\"631\" height=\"469\" border=\"0\"></a>\n\n&nbsp;\n\nThe end-to-end prototype is hosted in Azure and Azure Media Services. Below is the information related to the prototype.\n<ul>\n <li>URL of smooth streaming asset under AES dynamic encryption;</li>\n <li><a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086\" target=\"_blank\">Key delivery URL</a>;</li>\n <li><a href=\"https://willzhanacs.accesscontrol.windows.net/\">URL of Azure ACS namespace issuing SWT authorization token</a>;</li>\n <li>URL of the OSMF player;</li>\n</ul>\n&nbsp;\n<h2>How to Run it?</h2>\n<ol>\n <li>Browse to the OSMF player built with <a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\">Adaptive Streaming Plugin for OSMF</a>. The needed information is already on the player page UI.</li>\n <li>Notice that each click of \"Play\" button results in a request of new authorization token from ACS and the new authorization token is then used by the OSMF plugin to request for the decryption key for playback. The authorization token from ACS 2.0 namespace is shown on the player page. Below is the player screenshot.</li>\n</ol>\n<blockquote><a href=\"https://acom.azurecomcdn.net/80C57D/blogmedia/blogmedia/2014/11/19/OMFPlayer.jpg\"><img style=\"padding-top: 0px; padding-left: 0px; padding-right: 0px; border-width: 0px;\" title=\"OMFPlayer\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/OMFPlayer_thumb.jpg\" alt=\"OMFPlayer\" width=\"631\" height=\"341\" border=\"0\"></a></blockquote>\n&nbsp;\n<h1>The Implementation</h1>\nThe implementation involves the following:\n<ol>\n <li>Configure dynamic AES-128 encryption for an smooth streaming asset using Azure Media Services .NET API;\n<ul>\n <li>Generate content key ID and content key;</li>\n <li>Configure decryption key delivery service;</li>\n <li>Configure dynamic AES encryption via asset delivery policy;</li>\n <li>Publish the asset.</li>\n</ul>\n</li>\n <li>Set up an Azure ACS 2.0 namespace to authenticate the player client and issue authorization tokens;</li>\n <li>Develop a OSMF player which handles ACS authentication, authorization token request, decryption key request and video playback.</li>\n</ol>\nWe chose to use OSMF player for this prototype because Microsoft <a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\">Adaptive Streaming Plugin for OSMF</a> supports AES encryption of smooth streaming content for both on-demand and live.\n\n&nbsp;\n<h2>Configuring Dynamic AES Encryption</h2>\nThe first step is to create envelope type content key. The code is below.\n<div align=\"left\">\n<pre class=\"prettyprint\">static public IContentKey CreateEnvelopeTypeContentKey(CloudMediaContext objCloudMediaContext)\n{\n    // Create envelope encryption content key\n    Guid keyId = Guid.NewGuid();\n    byte[] contentKey = CryptoUtils.GenerateCryptographicallyStrongRandomBytes(16);\n\n    IContentKey objIContentKey = objCloudMediaContext.ContentKeys.Create(keyId, contentKey, \"myContentKey\", ContentKeyType.EnvelopeEncryption);\n\n    return objIContentKey;\n}</pre>\n</div>\nNext, we create the authorization policy and add it to the content key created above. As shown in <a href=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2331/8475.Blog_5F00_Secure_5F00_Delivery_5F00_API.jpg\" target=\"_blank\">this diagram</a>, each IContentKey has a single instance of IContentKeyAuthorizationPolicy. The following code creates an IContentKeyAuthorizationPolicy and attach to the IContentKey.\n<pre class=\"prettyprint\">public static IContentKey AddAuthorizationPolicyToContentKey(CloudMediaContext objCloudMediaContext, IContentKey objIContentKey)\n{\n    // Create ContentKeyAuthorizationPolicy with restrictions and create authorization policy             \n    IContentKeyAuthorizationPolicy policy = objCloudMediaContext.ContentKeyAuthorizationPolicies.CreateAsync(\"Open Authorization Policy\").Result;\n\n    List&lt;ContentKeyAuthorizationPolicyRestriction&gt; restrictions = new List&lt;ContentKeyAuthorizationPolicyRestriction&gt;();\n\n    ContentKeyAuthorizationPolicyRestriction restriction = new ContentKeyAuthorizationPolicyRestriction\n    {\n        Name = \"Authorization Policy with Token Restriction\",\n        KeyRestrictionType = (int)ContentKeyRestrictionType.TokenRestricted,\n        Requirements = ContentKeyAuthorizationHelper.CreateRestrictionRequirements()\n    };\n\n    restrictions.Add(restriction);\n\n    IContentKeyAuthorizationPolicyOption policyOption = objCloudMediaContext.ContentKeyAuthorizationPolicyOptions.Create(\"myDynamicEncryptionPolicy\", ContentKeyDeliveryType.BaselineHttp, restrictions, \"\");\n\n    policy.Options.Add(policyOption);\n\n    // Add ContentKeyAutorizationPolicy to ContentKey\n    objIContentKey.AuthorizationPolicyId = policy.Id;\n    IContentKey IContentKeyUpdated = objIContentKey.UpdateAsync().Result;\n\n    return IContentKeyUpdated;\n}</pre>\n&nbsp;\n\nIn the above, the method ContentKeyAuthorizationHelper.CreateRestrictionRequirements() is defined as below.\n<pre class=\"prettyprint\">public static string CreateRestrictionRequirements()\n{\n    string primarySymmetricKey   = System.Configuration.ConfigurationManager.AppSettings[\"PrimarySymmetricKey\"];\n    string secondarySymmetricKey = System.Configuration.ConfigurationManager.AppSettings[\"SecondarySymmetricKey\"];\n    string scope                 = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string issuer                = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n\n    TokenRestrictionTemplate objTokenRestrictionTemplate = new TokenRestrictionTemplate();\n\n    objTokenRestrictionTemplate.PrimaryVerificationKey = new SymmetricVerificationKey(Convert.FromBase64String(primarySymmetricKey));\n    objTokenRestrictionTemplate.AlternateVerificationKeys.Add(new SymmetricVerificationKey(Convert.FromBase64String(secondarySymmetricKey)));\n    objTokenRestrictionTemplate.Audience               = new Uri(scope);\n    objTokenRestrictionTemplate.Issuer                 = new Uri(issuer);\n\n    return TokenRestrictionTemplateSerializer.Serialize(objTokenRestrictionTemplate);\n}</pre>\n&nbsp;\n\n<strong>NOTE:</strong> Please make sure that the <strong>same</strong> (primary) symmetric hash key used in ACS 2.0 namespace is also used in configuring (dynamic) AES encryption authorization policy.\n\nNext, we need to create an IAssetDeliveryPolicy which will be used for the delivery of the asset:\n<pre class=\"prettyprint\">public static IAssetDeliveryPolicy CreateAssetDeliveryPolicy(CloudMediaContext objCloudMediaContext, IContentKey objIContentKey)\n{\n    Uri keyAcquisitionUri = objIContentKey.GetKeyDeliveryUrl(ContentKeyDeliveryType.BaselineHttp);\n\n    string envelopeEncryptionIV = Convert.ToBase64String(CryptoUtils.GenerateCryptographicallyStrongRandomBytes(16));\n\n    // The following policy configuration specifies: \n    //   key url that will have KID=&lt;Guid&gt; appended to the envelope and\n    //   the Initialization Vector (IV) to use for the envelope encryption.\n    Dictionary&lt;AssetDeliveryPolicyConfigurationKey, string&gt; assetDeliveryPolicyConfiguration = new Dictionary&lt;AssetDeliveryPolicyConfigurationKey, string&gt; \n            {\n                {AssetDeliveryPolicyConfigurationKey.EnvelopeKeyAcquisitionUrl, keyAcquisitionUri.ToString()},\n                {AssetDeliveryPolicyConfigurationKey.EnvelopeEncryptionIVAsBase64, envelopeEncryptionIV}\n            };\n\n    IAssetDeliveryPolicy objIAssetDeliveryPolicy = objCloudMediaContext.AssetDeliveryPolicies.Create(\n                \"SmoothHLSDynamicEncryptionAssetDeliveryPolicy\",\n                AssetDeliveryPolicyType.DynamicEnvelopeEncryption,\n                AssetDeliveryProtocol.SmoothStreaming | AssetDeliveryProtocol.HLS,\n                assetDeliveryPolicyConfiguration);\n\n    Console.WriteLine();\n    Console.WriteLine(\"Adding Asset Delivery Policy: \" + objIAssetDeliveryPolicy.AssetDeliveryPolicyType);\n    Console.WriteLine(\"Key Delivery URL = {0}\", keyAcquisitionUri.ToString());\n\n    return objIAssetDeliveryPolicy;\n}</pre>\n&nbsp;\n\nFinally, we combine all of above to form the following overall flow of adding AES dynamic encryption for an asset:\n<pre class=\"prettyprint\">public static void DynamicAesEncryptionFlow(CloudMediaContext objCloudMediaContext, IAsset objIAsset)\n{\n    //Create IContentKey\n    IContentKey objIContentKey = CreateEnvelopeTypeContentKey(objCloudMediaContext);\n\n    //add AuthorizationPolicy to IContentKey\n    objIContentKey = AddAuthorizationPolicyToContentKey(objCloudMediaContext, objIContentKey);\n\n    //create asset delivery policy\n    IAssetDeliveryPolicy objIAssetDeliveryPolicy = CreateAssetDeliveryPolicy(objCloudMediaContext, objIContentKey);\n\n    //Associate IContentKey with IAsset\n    objIAsset.ContentKeys.Add(objIContentKey);\n\n    // Add AssetDelivery Policy to the asset\n    objIAsset.DeliveryPolicies.Add(objIAssetDeliveryPolicy);\n}</pre>\nAfter running this, you need to publish the asset, either programmatically via API or using Azure portal.\n\n&nbsp;\n<h2>ACS Setup</h2>\nWe can simply use the same ACS 2.0 namespace we set up in the blog <a href=\"https://azure.microsoft.com/blog/2014/11/17/an-end-to-end-prototype-of-playready-protection-with-acs-authentication-and-acs-token-authorization/\" target=\"_blank\">An End-to-End Prototype of PlayReady Protection with ACS Authentication and ACS Token Authorization</a>, with the same symmetric verification key, same Service Identity, same issuer and scope, etc..\n\nWhen you set up ACS Service Identity, you may choose either Password or Symmetric Key credential types. Both cases are supported by the prototype (token request code below).\n\n&nbsp;\n<h2>Player Code</h2>\n<a href=\"https://azure.microsoft.com/blog/2014/10/27/microsoft-adaptive-streaming-plugin-for-osmf-update/\" target=\"_blank\">Microsoft Adaptive Streaming Plugin for OSMF</a> supports both on-demand and live playback of AES-128 encrypted smooth streaming. Therefore we use an OSMF player for our purpose. The flow of an OSMF player is as below:\n<ol>\n <li>Download smooth streaming manifest which indicates AES-128 encrypted content and contains the key delivery URL, as seen in the client manifest of our test asset.</li>\n <li>Request for authorization token;</li>\n <li>Request for decryption key with the authorization token;</li>\n <li>Decrypt and playback.</li>\n</ol>\nFirst the code to request authorization token from ACS namespace is as below.\n<pre class=\"prettyprint\">public string GetAcsToken()\n{\n    string issuer   = System.Configuration.ConfigurationManager.AppSettings[\"AcsIssuer\"];\n    string scope    = System.Configuration.ConfigurationManager.AppSettings[\"AcsScope\"];\n    string username = System.Configuration.ConfigurationManager.AppSettings[\"Username\"];\n    string password = System.Configuration.ConfigurationManager.AppSettings[\"Password\"];\n\n    string tokenToReturn = null;\n\n    using (WebClient client = new WebClient())\n    {\n        //  Create the authentication request to get a token\n        client.BaseAddress = (new Uri(issuer)).AbsoluteUri;\n\n        NameValueCollection objNameValueCollection = null;\n        switch (System.Configuration.ConfigurationManager.AppSettings[\"CredentialType\"].ToLower())\n        {\n            case \"password\":\n                objNameValueCollection = new NameValueCollection\n                {\n                    {\"grant_type\",    \"client_credentials\"},\n                    {\"client_id\",     username},\n                    {\"client_secret\", password},\n                    {\"scope\",         scope}\n                };\n                break;\n            case \"symmetrickey\":\n                objNameValueCollection = new NameValueCollection\n                {\n                    {\"grant_type\",    \"\"},\n                    {\"assertion\",     this.CreateToken(username, password)},\n                    {\"scope\",         scope}\n                };\n                break;\n            default:\n                break;\n        }\n\n        byte[] responseBytes = null;\n\n        try\n        {\n            responseBytes = client.UploadValues(new Uri(issuer + \"/v2/OAuth2-13/\"), \"POST\", objNameValueCollection);\n        }\n        catch (WebException we)\n        {\n            Stream stream = we.Response.GetResponseStream();\n            StreamReader reader = new StreamReader(stream);\n\n            throw;\n        }\n\n        using (var responseStream = new MemoryStream(responseBytes))\n        {\n            OAuth2TokenResponse tokenResponse = (OAuth2TokenResponse)new DataContractJsonSerializer(typeof(OAuth2TokenResponse)).ReadObject(responseStream);\n            tokenToReturn = tokenResponse.AccessToken;\n        }\n    }\n\n    return tokenToReturn;\n}\n\npublic string CreateToken(string issuer, string signingKey)\n{\n    System.Text.StringBuilder sb = new System.Text.StringBuilder();\n    // add the issuer name \n    sb.AppendFormat(\"Issuer={0}\", System.Web.HttpUtility.UrlEncode(issuer));\n    string signature = this.GenerateSignature(sb.ToString(), signingKey);\n    sb.AppendFormat(\"&amp;HMACSHA256={0}\", signature);\n    return sb.ToString();\n} \n\nprivate string GenerateSignature(string unsignedToken, string signingKey)\n{\n    System.Security.Cryptography.HMACSHA256 hmac = new System.Security.Cryptography.HMACSHA256(Convert.FromBase64String(signingKey));\n    byte[] locallyGeneratedSignatureInBytes = hmac.ComputeHash(System.Text.Encoding.ASCII.GetBytes(unsignedToken));\n    string locallyGeneratedSignature = System.Web.HttpUtility.UrlEncode(Convert.ToBase64String(locallyGeneratedSignatureInBytes));\n    return locallyGeneratedSignature;\n}</pre>\n&nbsp;\n\nThe type OAuth2TokenResponse is defined as:\n<pre class=\"prettyprint\">[DataContract]\npublic class OAuth2TokenResponse\n{\n    [DataMember(Name = \"access_token\")]\n    public string AccessToken { get; set; }\n\n    [DataMember(Name = \"expires_in\")]\n    public int ExpirationInSeconds { get; set; }\n}</pre>\n&nbsp;\n\nThe ASP.NET web page hosting the player is as below:\n<pre class=\"prettyprint\">&lt;%@ Page Language=\"C#\" AutoEventWireup=\"true\" CodeBehind=\"Aes128OSMFPlayer.aspx.cs\" Inherits=\"SilverlightApplication.Web.OSMF.Aes128OSMFPlayer\" %&gt;\n\n&lt;!DOCTYPE html&gt;\n\n&lt;html xmlns=\"https://www.w3.org/1999/xhtml\"&gt;\n&lt;head runat=\"server\"&gt;\n    &lt;title&gt;AES Encryption | OSMF Player&lt;/title&gt;\n    &lt;style type=\"text/css\"&gt;\n        .auto-style1 {\n            height: 17px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body style=\"font-family:Verdana;font-size:11px\"&gt;\n    &lt;form id=\"form1\" runat=\"server\"&gt;\n        &lt;div&gt;\n            &lt;h3&gt;End-to-End Prototype of AES Encryption with ACS Authorization Token for Smooth Streaming&lt;/h3&gt;\n            &lt;table&gt;&lt;tr&gt;&lt;td&gt;Source URL: &lt;/td&gt;&lt;td&gt;\n                &lt;asp:TextBox ID=\"txtSrcUrl\" runat=\"server\" Width=\"913px\"&gt;https://willzhanmediaservice.origin.mediaservices.windows.net/474c4840-4753-48ec-b3aa-9d05daef612a/LyncSkypeSizzleVideo750k.ism/manifest&lt;/asp:TextBox&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;Key Delivery URL:&lt;/td&gt;&lt;td&gt;&lt;a href=\"https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086\" target=\"_blank\"&gt;https://willzhanmediaservice.keydelivery.mediaservices.windows.net/?KID=1814f449-0550-4977-abd5-fe3efeaf6086&lt;/a&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n                &lt;tr&gt;&lt;td class=\"auto-style1\"&gt;Authorization Token:&lt;/td&gt;&lt;td class=\"auto-style1\"&gt;&lt;%=authorizationToken %&gt;&lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;Token Issuer: &lt;/td&gt;&lt;td&gt;&lt;a href=\"https://willzhanacs.accesscontrol.windows.net\" target=\"_blank\"&gt;https://willzhanacs.accesscontrol.windows.net&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;\n                &lt;asp:Button ID=\"cmdPlay\" runat=\"server\" OnClick=\"cmdPlay_Click\" Text=\"Play\" /&gt;\n            &lt;/td&gt;&lt;/tr&gt;\n            &lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;\n                    &lt;object width=\"920\" height=\"640\"&gt;\n                        &lt;param name=\"movie\" value=\"StrobeMediaPlayback.2.0.swf\"&gt;&lt;/param&gt;\n                        &lt;param name=\"flashvars\" value=\"src=&lt;%=srcUrl %&gt;&amp;autoPlay=&lt;%=autoPlay %&gt;&amp;plugin_AdaptiveStreamingPlugin=MSAdaptiveStreamingPlugin-v1.0.12-osmf2.0.swf&amp;AdaptiveStreamingPlugin_retryLive=true&amp;AdaptiveStreamingPlugin_retryInterval=10&amp;AdaptiveStreamingPlugin_encryptionKeyToken=&lt;%=authorizationToken %&gt;\"&gt;&lt;/param&gt;\n                        &lt;param name=\"allowFullScreen\" value=\"true\"&gt;&lt;/param&gt;\n                        &lt;param name=\"allowscriptaccess\" value=\"always\"&gt;&lt;/param&gt;\n                        &lt;param name=\"wmode\" value=\"direct\"&gt;&lt;/param&gt;\n                        &lt;embed src=\"StrobeMediaPlayback.2.0.swf\"\n                            type=\"application/x-shockwave-flash\"\n                            allowscriptaccess=\"always\"\n                            allowfullscreen=\"true\"\n                            wmode=\"direct\"\n                            width=\"920\"\n                            height=\"640\"\n                            flashvars=\"src=&lt;%=srcUrl %&gt;&amp;autoPlay=&lt;%=autoPlay %&gt;&amp;plugin_AdaptiveStreamingPlugin=MSAdaptiveStreamingPlugin-v1.0.12-osmf2.0.swf&amp;AdaptiveStreamingPlugin_retryLive=true&amp;AdaptiveStreamingPlugin_retryInterval=10&amp;AdaptiveStreamingPlugin_encryptionKeyToken=&lt;%=authorizationToken %&gt;\"&gt;\n                        &lt;/embed&gt;\n                    &lt;/object&gt;\n                &lt;/td&gt;&lt;/tr&gt;\n                &lt;/table&gt;\n        &lt;/div&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n&nbsp;\n\nAnd the corresponding code-behind is below:\n<pre class=\"prettyprint\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.UI;\nusing System.Web.UI.WebControls;\n\nnamespace SilverlightApplication.Web.OSMF\n{\n    public partial class Aes128OSMFPlayer : System.Web.UI.Page\n    {\n        protected string authorizationToken;\n        protected string autoPlay;\n        protected string srcUrl;\n        protected void Page_Load(object sender, EventArgs e)\n        {\n            if (!Page.IsPostBack)\n            {\n                this.Play();\n            }\n        }\n\n        protected void cmdPlay_Click(object sender, EventArgs e)\n        {\n            this.Play();\n        }\n\n        protected void Play()\n        {\n            //Request authorization token from ACS 2.0 namespace\n            WCFService objWCFService = new WCFService();\n            string token = objWCFService.GetAcsToken();\n            token = string.Format(\"Bearer={0}\", token);\n\n            //URL-encode the token before using it\n            authorizationToken = System.Web.HttpUtility.UrlEncode(token);\n\n            srcUrl = txtSrcUrl.Text;\n            autoPlay = true.ToString();\n        }\n    }\n}</pre>\n&nbsp;\n<h1>Wrap-up</h1>\nWe have presented an end-to-end prototype of Azure Media Services AES encryption solution which includes all of the key components:\n<ol>\n <li>Content key ID and content key generation;</li>\n <li>Streaming origin in Azure Media Services;</li>\n <li>AES encryption via Azure Media Services Content Protection;</li>\n <li>AES key delivery via Azure Media Services Content Protection;</li>\n <li>STS (Secure Token Service) via Azure ACS 2.0 to authenticate player client and issue authorization tokens;</li>\n <li>Video player application hosted in Azure IaaS VM, which handles ACS authentication, ACS authorization, decryption key acquisition and video playback.</li>\n</ol>\n&nbsp;\n\n<strong>UPDATES:</strong>\n\nOn 1/6/2015: The OSMF-plugin player has been enhanced for testing AES encryption in more general scenarios: It now works with any Azure ACS namespace instead of just the ACS namespace used for the end-to-end implementation discussed in this blog. You can just replace my ACS namespace parameters/secrets by yours to test.\n\nOn 1/23/2015: With the release of JWT support in AMS Content Protection, this prototype has been expanded to include token restriction with JWT by using Azure Active Directory (AAD) as both STS and IdP. AMS batch job (for setting up dynamic PlayReady protection or AES encryption): knows AAD tenant, but nothing about player app (any player is fine). AAD tenant: knows player app, but nothing about the AMS batch job. Player app: knows AAD tenant, but nothing about AMS or AMS batch job. In order words, AAD tenant and player app know each other. AMS batch job knows AAD tenant, but does not care what player consumes the contents.\n\n&nbsp;\n\n<b>ACKNOWLEDGMENT: </b>Special thanks to Quintin Burns, George Trifonov and Mingfei Yan of Microsoft Azure Media Services Team, who have provided significant help in this effort."
}