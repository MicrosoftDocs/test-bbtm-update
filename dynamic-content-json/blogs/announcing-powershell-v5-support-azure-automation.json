{
    "Slug": "announcing-powershell-v5-support-azure-automation",
    "Title": "Announcing PowerShell v5 support in Azure Automation",
    "Summary": "As you know, PowerShell version 5 has been released, and with it, a number of new PowerShell features. And now, you can take advantage of these great new PowerShell v5 features in your runbooks and DSC configurations in Azure Automation!",
    "Content": "<p>As you probably already know, PowerShell version 5 has been released, and with it, <a href=\"https://technet.microsoft.com/en-us/library/hh857339.aspx?f=255&amp;MSPPError=-2147217396#BKMK_new50\">a number of new PowerShell features</a>. Some of the most exciting features include:</p>\n\n<ul>\n <li>PowerShell classes</li>\n <li>PowerShell Workflow performance improvements</li>\n <li>PowerShell module side-by-side versioning</li>\n <li>A whole bunch of new cmdlets (ex. Convert-String)</li>\n <li>A whole bunch of PowerShell DSC improvements (ex. PSRunAsCredential)</li>\n</ul>\n\n<p>And now, you can take advantage of these same great PowerShell v5 features in your runbooks and DSC configurations in Azure Automation!</p>\n\n<p>There&rsquo;s no work on your part to use PowerShell v5 features in Azure Automation &ndash; but if you use hybrid runbooks workers and want to take advantage of PowerShell v5 features in runbooks you run on them, make sure you install WMF5 on those hybrid worker machines.</p>\n\n<p>Let&rsquo;s walk through how you&rsquo;d use some of the new PowerShell v5 features in Azure Automation.</p>\n\n<h2>PowerShell classes</h2>\n\n<p><a href=\"https://blogs.technet.com/b/heyscriptingguy/archive/2015/08/31/introduction-to-powershell-5-classes.aspx\">PowerShell classes</a> introduce object-oriented programming to PowerShell, making it easy to define new types of objects, instantiate them, and call methods on them.</p>\n\n<p>Use of PowerShell classes in Azure Automation can now be done exactly like in PowerShell v5. Take this native PowerShell runbook for example:</p>\n\n<pre class=\"prettyprint\">\nclass Coffee {\n    # Property: Holds the current size of the coffee.\n    [Uint32] $Size;\n    \n    # Property: Holds the name of the coffee&#39;s owner.\n    [String] $Owner;\n\n    # Constructor: Creates a new Coffee object, with the specified size and owner.\n    Coffee([UInt32] $NewSize, [String] $NewOwner) {\n        # Set the Coffee size\n        $this.Size = $NewSize;\n        \n        # Set the Coffee name\n        $this.Owner = $NewOwner;\n    }\n\n    # Method: Drink the specified amount of coffee.\n    # Parameter: $Amount = The amount of coffee to drink.\n    [void] Drink([UInt32] $Amount) {\n        $this.Size = $this.Size - $Amount;\n    }\n}\n\n# Create a new coffee object, with a size of 16 ounces, and &#39;Joe&#39; as its owner\n$MyCoffee = New-Object Coffee -ArgumentList 16, &quot;Joe&quot;\n\n# Drink 10 ounces\n$MyCoffee.Drink(10)\n\n# Output the object\n$MyCoffee \n</pre>\n\n<p>Testing this in Azure Automation returns the following:</p>\n\n<p><img alt=\"Announcing PowerShell v5 support in Azure Automation\" border=\"0\" height=\"244\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/bc0caa87-0ef5-4ca6-b7ba-5ad17704e947.png\" style=\"border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; float: none; margin-left: auto; display: block; border-top-width: 0px; margin-right: auto\" title=\"Announcing PowerShell v5 support in Azure Automation\" width=\"360\"></p>\n\n<p>PowerShell classes can be used in PowerShell Workflow based runbooks as well, but only within an InlineScript block.</p>\n\n<h2>PowerShell module side-by-side versioning</h2>\n\n<p>PowerShell side-by-side module versioning allows you to use more than one version of a module within PowerShell. This can be useful if you have some older scripts that have been tested as working against a certain version of a PowerShell module, but other scripts that demand a newer version of the same PowerShell module.</p>\n\n<p>Constructing PowerShell modules so they contain multiple versions is easy. You simply create the module folder as usual, and then create a folder within this module folder for each version of the module you want to be usable. Here&rsquo;s an example of that for a module TestModule I just created. As you can see, it provides two versions, 1.0.0 and 2.0.0.</p>\n\n<p><img alt=\"Announcing PowerShell v5 support in Azure Automation\" border=\"0\" height=\"246\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2c3ef265-a708-46a7-bfa3-c6cd8e471ed8.png\" style=\"border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; float: none; margin-left: auto; display: block; border-top-width: 0px; margin-right: auto\" title=\"Announcing PowerShell v5 support in Azure Automation\" width=\"360\">&nbsp;</p>\n\n<p>Within each of these &ldquo;version folders,&rdquo; you simply put the usual PowerShell PSM1, PSD1, and DLL files that make up a module. Here&rsquo;s what it looks like for version 1.0.0 of the module I created.</p>\n\n<p><img alt=\"Announcing PowerShell v5 support in Azure Automation\" border=\"0\" height=\"254\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/2dbd3ed1-8be3-40dc-b35e-3ba57369c8c3.png\" style=\"border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; float: none; margin-left: auto; display: block; border-top-width: 0px; margin-right: auto\" title=\"Announcing PowerShell v5 support in Azure Automation\" width=\"360\"></p>\n\n<p>Of course, if you&rsquo;re going to use this module within Azure Automation, you need to zip it up in order to import it. More info on PowerShell module use in Azure Automation can be found <a href=\"https://azure.microsoft.com/en-us/blog/authoring-integration-modules-for-azure-automation/\">here</a>.</p>\n\n<p>Once you&rsquo;ve zipped up and imported the module, it will show up like any other module within Azure Automation:</p>\n\n<p><img alt=\"Announcing PowerShell v5 support in Azure Automation\" border=\"0\" height=\"480\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4831cc96-2dbc-42b2-852b-17a9fbf1d826.png\" style=\"border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; float: none; margin-left: auto; display: block; border-top-width: 0px; margin-right: auto\" title=\"Announcing PowerShell v5 support in Azure Automation\" width=\"352\"></p>\n\n<p><b>Note: </b>While Azure Automation will only show that the latest (highest version number) version of the module is imported, if the module package contained side by side versions of the module, they are indeed all usable within your runbooks. But the UI will not show earlier versions of the module in that same package, currently.</p>\n\n<p><img alt=\"Announcing PowerShell v5 support in Azure Automation\" border=\"0\" height=\"360\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/f8efbf70-7acd-4780-bb1c-0e272dc8c691.png\" style=\"border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; float: none; margin-left: auto; display: block; border-top-width: 0px; margin-right: auto\" title=\"Announcing PowerShell v5 support in Azure Automation\" width=\"313\"></p>\n\n<p><b>Note #2: </b>While we do support modules containing side by side versions within the same package, we do not support using multiple versions of a module across module package imports.</p>\n\n<p>For example, if you imported module A, containing versions 1 and 2 into Azure Automation, and then later module A, containing versions 3 and 4 into Azure Automation, only versions 3 and 4 will be usable within any runbooks of DSC configurations. If you wanted versions 1, 2, 3, and 4 to be usable, the package you import should contain versions 1, 2, 3, and 4.</p>\n\n<p>Once the module containing side-by-side versions is imported, you can load a specific version as follows:</p>\n\n<p>PowerShell script runbooks:</p>\n\n<blockquote>\n<p><i>Import-Module &ndash;Name &lt;ModuleName&gt; -RequiredVersion &lt;version&gt;</i></p>\n</blockquote>\n\n<p>PowerShell Workflow runbooks (within an InlineScript block):</p>\n\n<blockquote>\n<p><i>Import-Module &ndash;Name &lt;ModuleName&gt; -RequiredVersion &lt;version&gt;</i></p>\n</blockquote>\n\n<p>DSC configurations:</p>\n\n<ul>\n <li>DSC Resource use:</li>\n</ul>\n\n<blockquote>\n<p><i>Import-DscResource -ModuleName &lt;ModuleName&gt; -ModuleVersion &lt;version&gt;</i></p>\n</blockquote>\n\n<ul>\n <li>Module use:</li>\n</ul>\n\n<blockquote>\n<p><i>Import-Module &ndash;Name &lt;ModuleName&gt; -RequiredVersion &lt;version&gt;</i></p>\n</blockquote>\n\n<p>Just like in the UI, by default the latest version of the module will be used at runtime. For example, my TestModule module contains a cmdlet called Get-MyVersion that outputs its module version. The following runbook:</p>\n\n<blockquote>\n<p><i>Get-MyVersion</i></p>\n</blockquote>\n\n<p>Will output:</p>\n\n<p><img alt=\"Announcing PowerShell v5 support in Azure Automation\" border=\"0\" height=\"259\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/72c644de-3c64-417d-b06e-9ba02ca23405.png\" style=\"border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; float: none; margin-left: auto; display: block; border-top-width: 0px; margin-right: auto\" title=\"Announcing PowerShell v5 support in Azure Automation\" width=\"360\">&nbsp;</p>\n\n<p>But if I explicitly load version 1.0.0 of the module in my runbook:</p>\n\n<blockquote>\n<p><i>Import-Module &ndash;Name TestModule -RequiredVersion 1.0.0</i></p>\n</blockquote>\n\n<blockquote>\n<p><i>Get-MyVersion</i></p>\n</blockquote>\n\n<p>It will output:</p>\n\n<p><em><img alt=\"Announcing PowerShell v5 support in Azure Automation\" border=\"0\" height=\"266\" src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4b5402f2-a195-40b1-b965-feb2b77ae410.png\" style=\"border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; float: none; margin-left: auto; display: block; border-top-width: 0px; margin-right: auto\" title=\"Announcing PowerShell v5 support in Azure Automation\" width=\"360\"> </em></p>\n\n<p>To be safe, if you&rsquo;re going to use different versions of the same module between runbooks, you should always declare the version you want to use in your runbook via Import-Module. Even if the version you want to use is the latest version. This is because jobs of your runbooks may run in the same sandbox. If the sandbox has already explicitly loaded a module of a certain version number (because a previous job in that sandbox said to do so), future jobs in that sandbox will not automatically load the latest version of that module (because some version of it is already loaded).</p>\n\n<h2>Summary</h2>\n\n<p>As you can see, PowerShell v5 has many great new features. Now these features can be taken advantage of in Azure Automation!</p>\n\n<p>Just getting started with Azure Automation? Learn about the service <a href=\"https://aka.ms/Q2p1ap\">here</a>, and follow Azure Automation on <a href=\"https://twitter.com/AzureAutomation\">Twitter</a> for the latest and greatest.</p>\n"
}