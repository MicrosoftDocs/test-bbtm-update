{
    "Slug": "adal-net-3-17-0-released-2",
    "Title": "ADAL.NET 3.17.0 released",
    "Summary": "ADAL.NET (Microsoft.IdentityModel.Clients.ActiveDirectory) is an authentication library which enables developers to acquire tokens from Azure AD and ADFS, to be used to access Microsoft APIs or applications registered with Azure Active Directory. ADAL.NET is available on several .NET platforms (Desktop, Universal Windows Platform, Xamarin / Android, Xamarin iOS, Portable Class Libraries, and .NET Core).",
    "Content": "<p>ADAL.NET (<a href=\"https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory/\">Microsoft.IdentityModel.Clients.ActiveDirectory</a>) is an authentication library which enables developers to acquire tokens from Azure AD and ADFS to access Microsoft APIs or applications registered with Azure Active Directory. ADAL.NET is available on several .NET platforms including Desktop, Universal Windows Platform, Xamarin / Android, Xamarin iOS, Portable Class Libraries, and .NET Core. We just released ADAL.NET 3.17.0 which enables new capabilities and brings improvements in terms of usability, privacy, and performance.</p>\n\n<h2>Enabling new capabilities</h2>\n\n<p>ADAL.Net 3.17.0 enables you to:</p>\n\n<ul>\n\t<li>Write more efficient applications, tolerant to Azure AD throttling.</li>\n\t<li>Force end users of your apps to choose an identity even when s/he is logged-in.</li>\n\t<li>Process more effective conditional access.</li>\n</ul>\n\n<h3>Enabling more efficient applications (Retry-After for instance)</h3>\n\n<p>You might have seen some of our samples processing, acquiring, and catching an <em>AdalException</em> with an ErrorCode <em>&quot;temporarily_unavailable&quot;.</em> When the Service Token Server (STS) is too busy because of &ldquo;too many requests&rdquo;, it returns an HTTP error 429 with a hint about when you can try again (Retry-After response field) as a delay in seconds, or a date.</p>\n\n<p>Previously, ADAL.NET did not surface this information. Therefore, to handle the error we advised to retry an arbitrary number of times after waiting for a hard-coded arbitrary delay. For a console application, the code could look like the following:</p>\n\n<pre class=\"prettyprint\">\ndo\n{\n    retry = false;\n    try\n    {\n        result = await authContext.AcquireTokenAsync(resource, certCred);\n    }\n    catch (AdalException ex)\n    {\n        if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n            retry = true;\n            retryCount++;\n            Thread.Sleep(3000);\n        }\n\t  &hellip;\n    }\n     &hellip;\n} while ((retry == true) &amp;&amp; (retryCount &lt; 2)); \n</pre>\n\n<p>From ADAL.NET 3.17.0, we are now surfacing the System.Net.Http.Headers<em>.HttpResponseH</em>eaders as a new property named Headers in the <em>AdalServiceException</em>. Therefore, you can leverage additional information to improve the reliability of your applications. In the case we just described, you can use the RetryAfter property (of type <em>RetryConditionHeaderValue</em>) and compute when to retry.</p>\n\n<p><strong>Note that</strong> depending on whether you are using ADAL.Net for a confidential client <a href=\"https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-authentication-scenarios#application-types-and-scenarios\">application</a> or a public client application, you will have to catch the <em>AdalServiceException </em>directly or as an InnerException of the <em>AdalException.</em></p>\n\n<p>The following code snippet should give you an idea of how to proceed depending on the case:</p>\n\n<pre class=\"prettyprint\">\ndo\n{\n    retry = false;\n    TimeSpan ?delay;\n    try\n    {\n        result = await authContext.AcquireTokenAsync(resource, certCred);\n    }\n\n    // Case of a Confidential client flow \n    // (for instance auth code redemption in a Web App)\n    catch (AdalServiceException serviceException)\n    {\n\t if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n\t\tRetryConditionHeaderValue retry= serviceException.Headers.RetryAfter;\n\t\tif (retry.Delta.HasValue)\n              {\n\t\t\tdelay = retry.Delta;\n              }\n\t\telse if (retry.Date.HasValue)\n              {\n\t\t\tdelay = retry.Date.Value.Offset;\n              }\n        }\n\n    }\n    \n    // Case of a client side exception\n    catch (AdalException ex)\n    {\n        if (ex.ErrorCode == &quot;temporarily_unavailable&quot;)\n        {\n     var serviceEx = ex.InnerException as AdalServiceException;\n    // Same kind of processing as above\n        }\n\t&hellip;\n    }\n    &hellip;\n   if (delay.HasValue)\n   {\n\tThread.Sleep((int)delay.Value.TotalSeconds); // sleep or other\nretry = true;\n   }\n\n} while (retry); \n</pre>\n\n<h3>Forcing the user to select an account</h3>\n\n<p>More people are using multiple personal, professional, and organization identities. You might have a use case in your application where you want your user to choose which identity to use. To enable such use cases, we added a new value <em>SelectAccount</em> in the <em>PromptBehavior</em> enumeration for the platforms supporting interaction (Desktop, WinRT, Xamarin iOS, and Xamarin Android). If you use it, you will force your app&rsquo;s user to choose an account, even when s/he is already logged-in, bypassing the cache lookup, and presenting the UI directly.</p>\n\n<p>You might have used <em>PromptBehavior</em>.<em>Always</em> in the past, which also bypasses the token cache and presents a User interface. <em>PromptBehavior</em>.<em>SelectAccount</em> is different because it tells Azure AD to display available users as tiles and does not force users to sign in again (assuming the cookies are available, remember the interaction between the user and Azure AD happens in a browser). The presence of tiles does not guarantee a Single Sign On experience because the behavior is determined by the cookie lifetime that it managed completely outside the library&rsquo;s purview.</p>\n\n<h3>Enabling your applications to handle conditional access (and other claim challenges)</h3>\n\n<p>We try to keep most of our <a href=\"https://github.com/Azure-Samples?utf8=%E2%9C%93&amp;q=azure-active-directory\">samples</a> simple, however, you probably know that if you want to produce enterprise ready applications, you will have to put a bit more effort into error handling. To that effect, in ADAL.NET 3.16.0, we enable you to process claim challenges sent by Azure AD when your application needs to involve the user to let him accept that the application access additional resources, or to let him do multi-factor authentication. In ADAL.NET 3.17.0, we enabled this feature by passing back to the API caller the <em>HttpRequestWrapperException</em> as an inner exception to <em>AdalClaimChallengeException</em> so that you can get missing claims. You can then pass these additional claims to the acquireToken overrides which have a new claims member.</p>\n\n<p>The code snippet below is extracted from the <a href=\"https://github.com/Azure-Samples/active-directory-dotnet-webapi-onbehalfof-ca/blob/master/TodoListService/Controllers/AccessCaApiController.cs#L88-L98\">active-directory-dotnet-webapi-onbehalfof-ca</a> sample. It illustrates the claim challenge received from Azure AD by the TodoList service (confidential client) and how this challenge is propagated to the clients so that they can, in their turn, have the needed user interaction (for instance two-factor authentication).</p>\n\n<pre class=\"prettyprint\">\ntry\n{\n    result = await authContext.AcquireTokenAsync(caResourceId, clientCred,\n                                                 userAssertion);\n}\ncatch (AdalClaimChallengeException ex)\n{\n    HttpResponseMessage myMessage = new HttpResponseMessage \n    { StatusCode = HttpStatusCode.Forbidden, ReasonPhrase = INTERACTION_REQUIRED,\n      Content = new StringContent(ex.Claims) };\n    throw new HttpResponseException(myMessage);\n}\ncatch (AdalServiceException ex)\n{\n  &hellip;\n</pre>\n\n<p>On the client side (TodoListClient), the code getting this challenge when calling the TodoList service and re-requesting the token with more claims is the following:</p>\n\n<pre class=\"prettyprint\">\n// We successfully got a token.\nhttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, result.AccessToken);\n\n// while calling the API.\nHttpResponseMessage response = await httpClient.GetAsync(todoListBaseAddress \n                                                         + &quot;/api/AccessCaApi&quot;);\n\nif (response.StatusCode == System.Net.HttpStatusCode.Forbidden \n    &amp;&amp; response.ReasonPhrase == INTERACTION_REQUIRED)\n {\n     // We need to re-request the token to account for a Conditional Access Policy\n     String claimsParam = await response.Content.ReadAsStringAsync();\n\n    try\n    {\n     result = await authContext.AcquireTokenAsync(todoListResourceId, clientId,\n                     redirectUri, new PlatformParameters(PromptBehavior.Always), \n                     new UserIdentifier(displayName,\n                                        UserIdentifierType.OptionalDisplayableId),\n                     extraQueryParameters:null, \n                     claims: claimsParam);\n     &hellip;\n</pre>\n\n<p>More details are described in the <a href=\"https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-conditional-access-developer\">Developer Guidance for Azure Active Directory Conditional Access</a> and the samples linked from this article.</p>\n\n<h2>Usability improvements</h2>\n\n<h3>ADAL.NET NuGet package now contains one DLL for each platform</h3>\n\n<p>ADAL.NET used to be packaged as one common assembly which dynamically loaded another platform specific assembly using dependency injection. This was causing issues (like #511). When you were referencing the NuGet package from a portable library, you also had to reference the platform specific assembly from your main assembly, which was not very intuitive.</p>\n\n<p>Starting with ADAL.NET 3.17.0, the NuGet package now contains a single DLL for each platform.</p>\n\n<p>In case you are interested in the implementation details, have a look at ADAL.NET&rsquo;s source code on GitHub, you&rsquo;ll see that we&rsquo;ve moved to a <a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Clients.ActiveDirectory/Microsoft.IdentityModel.Clients.ActiveDirectory.csproj#L11\">multi-target project</a> for ADAL.NET.</p>\n\n<h3>Removing confusion by hiding the APIs which did not make sense in some platforms</h3>\n\n<p><strong>WinRT Apps can now only use one ClientCredential constructor</strong></p>\n\n<p>Even if WinRT applications are generally public client applications, they can also use client credential flow to enable kiosk mode scenarios where no user is logged-in. So far the <em>ClientCredential</em> class used in confidential client scenarios had two overrides:</p>\n\n<ul>\n\t<li>One with application secret, <em>public ClientCredential(string clientId, string clientSecret).</em></li>\n\t<li>One that redeems an <em>authorizationcode</em> or pass in a user assertion.</li>\n</ul>\n\n<p>The later did not make sense for WinRT applications. It&rsquo;s now only available on desktop applications.</p>\n\n<p><strong>Device Profile API is now only available in Desktop, .NET core and UWP apps</strong></p>\n\n<p>The Device Profile API <em>AcquireTokenByDeviceCodeAsync(DeviceCodeResult deviceCodeResult)</em> acquires a security token from the STS using a device code previously requested using one of the overrides of <em>AcquireDeviceCodeAsync</em> (See <a href=\"https://azure.microsoft.com/en-us/resources/samples/active-directory-dotnet-deviceprofile\">Invoking an API protected by Azure AD from a text-only device</a>). <em>AcquireTokenByDeviceCodeAsync</em> is no longer available for Xamarin iOS and Xamarin Android which are not text-only devices. It should only be used in desktop, .Net Core and UWP (for IoT) apps. This is making things more consistent as <em>AcquireDeviceCodeAsync</em> was already not available for Android and iOS.</p>\n\n<h3>Improved documentation</h3>\n\n<p>We fixed a number of issues in the reference documentation, which was confusing for UserPasswordCredential and AcquireToken (See <a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/issues/654\">#654</a>). We also updated the library&rsquo;s readme.md with instructions on how to enable logging by implementing the <em>IAdalLogCallback</em> interface, and how to interact with an external broker (case of Xamarin iOS / Xamarin Android).</p>\n\n<h2>Privacy and performance improvements</h2>\n\n<p>As you might know, you can activate Logging in ADAL.NET logger by assigning to <em>LoggerCallbackHandler</em>. Callback is an instance of a class implementing the <em>IAdalLogCallback </em>interface. When you did that, and chose to see Verbose information, when ADAL.Net was sending a request to Azure AD, you could see two messages.</p>\n\n<ul>\n\t<li><em>&ldquo;Navigating to &lsquo;complete URL&rsquo;&rdquo;</em></li>\n\t<li><em>&ldquo;Navigated to &lsquo;complete URL&rsquo;&rdquo;</em></li>\n</ul>\n\n<p>Where <em>&lsquo;Complete URL&rsquo;</em> was the complete URL sent to Azure AD. Including, with some prompt behaviors, personal information such as the User Principal Name (UPN) of the user.</p>\n\n<p>We improved privacy by no longer logging the complete URL.</p>\n\n<p>We also improved performance by fixing a memory leak specific to the Xamarin iOS platform.</p>\n\n<h2>In closing</h2>\n\n<p>As usual we&rsquo;d love to hear your feedback. Please:</p>\n\n<ul>\n\t<li>Ask questions on&nbsp; <a href=\"https://stackoverflow.com/questions/tagged/adal\">Stack Overflow</a> using the ADAL tag.</li>\n\t<li>Use <a href=\"https://github.com/AzureAD/azure-activedirectory-library-for-dotnet/issues\">GitHub Issues</a> on the ADAL.Net open source repository to report bugs or request features</li>\n\t<li>Use the <a href=\"https://feedback.azure.com/forums/169401-azure-active-directory\">User Voice page</a> to provide recommendations and/or feedback</li>\n</ul>\n"
}