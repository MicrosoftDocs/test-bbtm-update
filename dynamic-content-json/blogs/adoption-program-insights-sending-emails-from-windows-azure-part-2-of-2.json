{
    "Slug": "adoption-program-insights-sending-emails-from-windows-azure-part-2-of-2",
    "Title": "Adoption Program Insights: Sending Emails from Windows Azure (Part 2 of 2)",
    "Summary": "The  Adoption Program Insights series describes experiences of Microsoft Services  consultants involved in the Windows Azure Technical Adoption Program assisting customers deploy solutions on theâ€¦",
    "Content": "<p><i>The  Adoption Program Insights series describes experiences of Microsoft Services  consultants involved in the Windows Azure Technical Adoption Program</i> <i>assisting</i> <i>customers deploy solutions on the Windows  Azure platform. This post is by Norman Sequeira, Patrick Butler Monterde and Tom Hollander.</i></p>  <p>This is the second part of a two-part series  describing options for sending emails from <a target=\"_blank\" href=\"https://azure.microsoft.com/\">Windows Azure</a> applications. In Part 1 we described a pattern  that uses a custom on-premise Email  Forwarder Service to send mails on behalf of a Windows Azure application. In  this post we describe how to use your email server's web services APIs to  accept messages directly from a Windows Azure application.</p>  <h2>Pattern  2: Using Email Server's Web Services APIs</h2>  <p>This pattern leverages the web services  capability of Exchange Server 2007 or Exchange Server 2010 to send email out  directly from the Windows Azure platform. This approach could also be used  other email servers that provide web service interfaces, however this post only  describes the implementation for Microsoft Exchange Server.</p>  <p>Since both web and worker roles can make  outbound connections to Internet resources via HTTP or HTTPS, it is possible  for the web/worker roles to communicate with the web services hosted on  Exchange Server. Both Exchange Server 2007 and Exchange Server 2010 support EWS  (Exchange Web Services) as an interface for automation. Exchange Web Services  offers rich feature set which supports most common mail automation related  scenarios like sending email, adding attachments, checking a user's mailbox,  configuring delegate access etc. For a full list of features supported by EWS,  please check out <a target=\"_blank\" href=\"https://msdn.microsoft.com/en-us/library/dd877045.aspx\">this  MSDN article</a>.</p>  <p>If your organisation has opted to use Exchange Online  instead of an on-premise email server, the same EWS based approach can be used  from Windows Azure without any code changes since both Exchange Online Standard  and Exchange Online Dedicated offer EWS support. Exchange Online is a part of  the Microsoft Business Productivity Online Suite (BPOS) which is a set of  messaging and collaboration solutions offered by Microsoft.</p>  <p>The following diagram shows how a Windows  Azure application could leverage EWS to send emails on its behalf:</p>  <p><a target=\"_blank\" href=\"https://msdn.microsoft.com/en-us/library/dd877045.aspx\"><img src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/7802.EmailPt2Graphic1.png\" border=\"0\"></a></p>  <h3>Sample Code</h3>  <p>The <a target=\"_blank\" href=\"https://www.microsoft.com/downloads/details.aspx?displaylang=en&amp;FamilyID=c3342fb3-fbcc-4127-becf-872c746840e1\">EWS  Managed API</a> provides strongly typed .NET interfaces for interacting with  the Exchange Web Services. Once the Exchange Web Services Managed API is  installed, your first step is to add a reference to the  Microsoft.Exchange.WebServices.dll in your existing Windows Azure project in  Visual Studio:</p>  <p><a target=\"_blank\" href=\"https://www.microsoft.com/downloads/en/details.aspx?displaylang=en&amp;FamilyID=c3342fb3-fbcc-4127-becf-872c746840e1\"><img src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/4152.EmailPt2Graphic2.png\" border=\"0\"></a></p>  <h3>Using the EWS Managed API against a Test  Server</h3>  <p>Test servers are deployed with self-signed  certificates, which are not trusted by the Microsoft .NET Framework. If you use  the EWS Managed API against a test server, you might receive the following  error:</p>  <p><a target=\"_blank\" href=\"https://www.microsoft.com/downloads/en/details.aspx?displaylang=en&amp;FamilyID=c3342fb3-fbcc-4127-becf-872c746840e1\"><img src=\"https://azurecomcdn.azureedge.net/mediahandler/acomblog/media/Default/blog/0361.EmailPt2Graphic3.png\" border=\"0\"></a></p>  <p>To resolve this issue, you can write code  to disable certificate validation in test scenarios. You should use #if DEBUG  or similar techniques to ensure this code is not used for production scenarios!  </p>  <p>using  System.Net.Security;<br>  using  System.Security.Cryptography.X509Certificates;</p>  <p>//  Hook up the cert callback.<br>  System.Net.ServicePointManager.ServerCertificateValidationCallback  =<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delegate(<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object obj,<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509Certificate certificate,<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X509Chain chain,<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SslPolicyErrors errors)<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Validate the certificate and return true or false as  appropriate.<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Note that it not a good practice to always return true  because not<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all certificates should be trusted.<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</p>  <h3>Creating an Instance of the  ExchangeService Object</h3>  <p>Next it's  time to connect to the server by creating and configuring an <b>ExchangeService</b><b> </b>instance. Note the use of <b>Autodiscover</b>  to determine the service's URL based on an e-mail address:</p>  <p>ExchangeService service  = new ExchangeService(ExchangeVersion.Exchange2007_SP1);</p>  <p>//Retrieve the  credential settings from the Azure configuration</p>  <p>string  userName = RoleEnvironment.GetConfigurationSettingValue(\"EWSUserName\");</p>  <p>string  password = RoleEnvironment.GetConfigurationSettingValue(\"EWSPassword\");</p>  <p>string domain  = RoleEnvironment.GetConfigurationSettingValue(\"EWSDomain\");</p>  <p>service.Credentials = new  WebCredentials(userName, password, domain);<b></b></p>  <p>// In case the  EWS URL is not known, then the EWS URL can also be derived automatically by the  EWS Managed API </p>  <p>// using the  email address of a mailbox hosted on the Exchange server</p>  <p>string  emailAddress = RoleEnvironment.GetConfigurationSettingValue(\"emailAddress\");</p>  <p>service.AutodiscoverUrl(emailAddress); </p>  <h3>Sending Email</h3>  <p>Once an instance of the <b>ExchangeService</b> object has been created  and initialized, it can be used for sending/receiving mails.</p>  <p>EmailMessage message  = new EmailMessage(service);</p>  <p>message.ToRecipients.Add(\"someone@server.com\");</p>  <p>message.From = new EmailAddress(\"someone@azureapp.com\");</p>  <p>message.Subject = \"Sending mail from Windows Azure\";</p>  <p>message.Body = new MessageBody(BodyType.HTML, \"This  is the body of the mail sent out from Windows Azure environment\");</p>  <p>//code for  sending attachments.</p>  <p>//The  AddFileAttachment method takes in a 'display name' and 'byte array' as  parameters</p>  <p>message.Attachments.AddFileAttachment(\"Attachment1\", attachment1);</p>  <p>//The  following property 'ContentId' is used in case the attachment needs to be  referenced from the body of the mail</p>  <p>message.Attachments[0].ContentId  = \"Attachment1\";</p>  <p>// The  following method sends the mail and also saves a copy in the 'Sent Items'  folder</p>  <p>message.SendAndSaveCopy();</p>  <h3>Architectural Considerations<br></h3>  <p>It is important to understand the  architectural implications for any solution. Some of the considerations for the  Email Server Web Service APIs approach include:</p>  <ul class=\"unIndentedList\">  <li>  <b>Cost:</b> Outbound data flow from Windows  Azure to EWS will incur the additional cost to the overall solution. The  overall cost impact will vary based on the email volume and bandwidth usage in  individual solution, that must be studied carefully before the implementation  of this pattern.</li>  <li>  <b>Performance: </b>Large email attachments may  pose some performance impact since these needs to be serialized and downloaded  to the Exchange Servers by using EWS (on-premise or online). This must also be  considered carefully.</li>  </ul>  <h3>Summary</h3>  <p>Even though Windows Azure does not include  its own native SMTP server, there are several options for building applications  that send emails. If you have an on-premise email server, you can use Windows  Azure storage to send messages to a custom Email Forwarder Service which then  forwards them onto your email server. If your email server exposes a web  services API, you can use this to communicate directly instead of using a  custom service. And if you have direct access to a SMTP server (including a  commercial service) you can configure your Windows Azure app to use that.</p>  <p>One final comment - no matter which of  these approaches you use, keep in mind that if your application needs to send  out a very large number of emails (for example, for user registrations) you may  run into problems if your email server is configured to limit email volume or  if the recipients' servers are likely to reject messages as spam. In this case  you will need to choose or configure your email server carefully to ensure your  messages make it to their final destination. </p>  <p><iframe src=\"https://www.facebook.com/plugins/like.php?href=;layout=box_count&amp;show_faces=false&amp;width=300&amp;action=like&amp;font=segoe+ui&amp;colorscheme=light&amp;height=50\" style=\"overflow: hidden; width: 300px; height: 50px;\" frameborder=\"0\" scrolling=\"no\"></iframe><br><a data-url=\"\" data-count=\"horizontal\" data-via=\"Windowsazure\" href=\"https://twitter.com/share\" class=\"twitter-share-button\">Tweet</a>  <script src=\"https://platform.twitter.com/widgets.js\" type=\"text/javascript\"></script>  </p>"
}